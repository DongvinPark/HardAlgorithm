### 문제 제목 - numbers 배열 내부에 존재하는 숫자들을 중복 허용해서 이용하면서 타깃 숫자 만들기
## 문제 상황 설명
- numbers 배열 내의 숫자를 이용해서 타깃 숫자를 만드는 것에 필요한 연산의 횟수를 구하시오.
- 이때, numbers 배열 내의 숫자를 중복 사용이 가능하다.
- 더하거나 곱하는 연산 둘 중 하나의 연산을 사용할 수 있다.

- Ex : numbers = {1,2,4}, target == 12 라면,
<br> 세번째 연산에서 (1 + 2) * 3 == 12로 타깃 숫자를 만들어 낼 수 있으므로 답은 3이다.

<br>

## 정답률 100% 코드

<br>

```java
class Solution {
    public int solution(int[] numbers, int target){
        int ans=1;

        Set<Integer> set = new HashSet<>();
        Arrays.stream(numbers).forEach(
                set::add
        );

        // 단 한 번만 뽑아서 바로 만들 수 있는 경우
        if(set.contains(target)) return 1;

        // 연산을 더 해봐야 하는 경우.
        // 예를 들어서 Numbers가 1,2,4 이고, 타깃 숫자가 12라고 하자.
        /*
        아래의 포문에 처음 진입할 때 셋 내부에는 1,2,4가 들어 있을 것이다.

        *** 나왔던 숫자를 중복으로 사용할 수 있다는 것이 핵심이다!!!

        두 번째 계산에서는 1,2,4 각각에 대해서 + 1, + 2, + 4, * 1, * 2, * 4 가
        진행되는 것이다.
        그리고 이 결과는 새로운 해시셋에 저장된다. 셋이 알아서 중복을 걸러주기 때문에 계산 결과를
        무조건 셋에 더해주기만 하면 된다.

        새로운 해시셋이 타깃 12를 포함하고 있다면 ans를 반환하면 된다.

        없다면, 새로운 해시셋의 참조가 기존 해시셋의 참조를 대신하게 만든 후, 다음 루프를 진행하면 된다.

        두 번째 계산 결과로 기존 해시셋 안에 존재하게 되는 값은

        1 + (1,2,4) >> 2,3,4
        1 X (1,2,4) >> 1 (중복제거!!)
        2 + (1,2,4) >> 8 (중복제거!!)
        2 X (1,2,4) >> 정부 중복된다.
        4 + (1,2,4) >> 16 (중복제거!!)
        4 X (1,2,4) >> 전부 중복된다.

        세 번째에서 3 * 4 를 통해서 원하는 값을 바로 만들어낼 수 있게 된다.

        이러한 루프를 9999 번(최초의 1 루프는 기존 해시셋을 처음 만들 때 실행되었으므로)
        돌렸는데도 타깃을 만들어내지 못했다면 -1을 리턴하면 된다.

        * */
        for(int i = 2; i<= 10_000; i++){
            ans++;
            Set<Integer> newSet = new HashSet<>();

            for(int n : set){
                for(int k : numbers){
                    // 이렇게 최적화를 해주지 않으면 시간이 오지게 많이 걸린다.
                    if((n+k) <= target) newSet.add(n + k);
                    if((n*k) <= target) newSet.add(n * k);
                }
            }

            if(newSet.contains(target)){
                return ans;
            }

            // 또한, 새로운 셋의 사이즈가 0이라는 것은 앞으로 계산을 더 해봤자 전부 타깃을 초과하게 되므로
            // 더 이상 연산을 하는 것이 무의미함을 뜻한다. 따라서 -1을 리턴한다.
            if(newSet.size() == 0) return -1;

            set = newSet;

        }// O for


        return -1;
    }
 }
```
